Tema 2: Técnicas de virtualización
==

<!--@
prev: 1.Intro:concepto_y_soporte_fisico
next: 3.Uso_de_sistemas
-->

<div class="objetivos" markdown="1">

<h2>Objetivos</h2>

1.  Conocer las diferentes tecnologías y herramientas de
virtualización tanto para procesamiento, comunicación y
almacenamiento. 

2. Realizar tareas de administración en infraestructura virtual.

</div>


Introducción
------------------

Una vez vista la introducción a la infraestructura virtual y algunas
técnicas usadas por la misma, en este tema pondremos en práctica lo
anterior trabajando con diferentes técnicas de virtualización a nivel
de sistema operativo y a nivel de hardware.

Comenzaremos por aprender a usar *contenedores*, un entorno de
virtualización a nivel de sistema operativo que permite trabajar con
muchas de las técnicas habituales en virtualización sin introducir un
*overhead* excesivo; previamente veremos los mecanismos incluidos en
el núcleo que permiten construirlos.

Espacios de nombres
-------------------------------

Los
[espacios de nombres o *namespaces* del núcleo](http://lwn.net/Articles/531114/)
son un mecanismo que permite aislar el identificador asignado a una
serie de recursos del resto del sistema. Por ejemplo, se puede
identificar un número de proceso (PID) independiente, que puede
coincidir con otro existente en otro espacio de nombres, o se puede
montar un recurso de forma que sea invisible al resto del sistema o
simplemente tenga un nombre diferente.

Hay seis tipos de *namespaces*, algunso de los cuales son
relativamente modernos y otros proceden de las versiones 2.4 y 2.6 del
núcleo:

* De montaje, aislan los recursos declarados con `mount`
* UTS (el acrónimo viene de *Unix Time Sharing System*, sistemas de
  virtualización tempranos), básicamente los nombres del ordenador y
  su dominio
  * IPC o *inter-process communication*, referidos a los *sockets* y
    colas de mensajes
	* PID o identificadores de proceso
	* Red, los recursos relacionados con la red, números de puerto y
      demás.
	  * Usuario, lo que puede permitir, por ejemplo, que un proceso
        tenga privilegios de `root` dentro del espacio de nombres de
        un usuario y no los tenga fuera, creando contenedores de
        recursos.
		
La mayor parte de estos espacios de nombres se pueden asignar a una
nueva orden usando una llamada del sistema `CLONE`. Pero desde línea
de órdenes se pueden crear diferentes espacios de nombres usando
`unshare`, que está dentro del paquete `util-linux` (es posible que se
llame de otra forma en diferentes distribuciones) como
[cuentan en este blog](http://karelzak.blogspot.com.es/2009/12/unshare1.html). Por
ejemplo, podemos cambiar el nombre de la máquina:

![Usando lxc-chkconfig](../img/unshare.png)

Primero, se ha usado

   sudo unshare -u /bin/bash
   
En este caso, `-u` indica que vamos a crear un nuevo *namespace* UTS,
que nos permite cambiar el nombre de la máquina. Eso es lo que
hacemos: cambiamos el nombre de la máquina, y comprobamos que al salir
de la orden que había ejecutado, el intérprete de órdenes, se vuelve a
restaurar el nombre original. 

<div class='ejercicios' markdown="1">

Crear un espacio de nombres y montar en él una imagen ISO de un CD de
forma que no se pueda leer más que desde él. *Pista*: en
[ServerFault](http://serverfault.com/questions/198135/how-to-mount-an-iso-file-in-linux)
nos explican como hacerlo, usando el dispositivo *loopback*

</div>

El mecanismo de espacios de nombres es diferente al usado en 
[`cgroups`](1.Intro:concepto_y_soporte_fisico#restriccin_y_medicin_del_uso_de_recursos_),
tal como se vio en el tema anterior: teóricamente, un PID dentro de un
CGROUP es visible a todos los demás procesos; sin embargo, es
complementario porque mientras que uno aisla la visibilidad o el
ámbito otro aisla o limita el uso de recursos. Por ello constituyen la
base de los contenedores que se verán en este tema.



   


Un primer paso de virtualización: *contenedores*
-------

El aislamiento de grupos de procesos formando una *jaula* o
*contenedor* ha sido una característica de ciertos sistemas operativos
de la rama Unix desde los años 80, en forma del programa
[chroot](http://es.wikipedia.org/wiki/Chroot) (creado por Bill Joy, el
que más adelante sería uno de los padres de Java). La limitación de
uso de recursos de las *jaulas `chroot`* se limitaba a la protección
del acceso a ciertos recursos del sistema de archivos, aunque son
relativamente fáciles de superar; incluso así, fue durante mucho
tiempo la forma principal de configurar servidores de alojamiento
compartidos. Las
[jaulas BSD](http://en.wikipedia.org/wiki/FreeBSD_jail) constituían un
sistema más avanzado, implementando una
[virtualización a nivel de sistema operativo](http://en.wikipedia.org/wiki/Operating_system-level_virtualization)
que creaba un entorno virtual prácticamente indistinguible de una
máquina real (o máquina virtual real). Estas *jaulas* no sólo impiden
el acceso a ciertas partes del sistema de ficheros, sino que también
restringían lo que los procesos podían hacer en relación con el resto
del sistema. Tiene como limitación, sin embargo, la obligación de
ejecutar la misma versión del núcleo del sistema.

El mundo Linux no tendría capacidades similares hasta los años 80, con
[vServers, OpenVZ y finalmente LXC](http://en.wikipedia.org/wiki/Operating_system-level_virtualization#Implementations). Este
último, [LXC](http://lxc.sourceforge.net), se basa en el concepto de
[grupos de control o CGROUPS](http://en.wikipedia.org/wiki/Cgroups),
una capacidad del núcleo de Linux desde la versión 2.6.24 que crea
*contenedores* de procesos unificando diferentes capacidades del
sistema operativo que incluyen acceso a recursos, prioridades y
control de los procesos. Los procesos dentro de un contenedor están
*aislados* de forma que sólo pueden *ver* los procesos dentro del
mismo, creando un entorno mucho más seguro que las anteriores
*jaulas*.

Dentro de la familia de sistemas operativos Solaris (cuya última
versión libre se denomina
[illumos](http://en.wikipedia.org/wiki/Illumos), y tiene también otras
versiones como SmartOS) la tecnología
correspondiente se denomina
[zonas](http://en.wikipedia.org/wiki/Solaris_Zones). La principal
diferencia es el bajo *overhead* que le añaden al sistema operativo y
el hecho de que se les puedan asignar recursos específicos; estas
diferencias son muy leves al tratarse simplemente de otra
implementación de virtualización a nivel de sistema operativo.

Un contenedor es una forma *ligera* de virtualización, en el sentido
que no requiere un hipervisor para funcionar ni, en principio, ninguno
de los mecanismos hardware necesarios para llevar a cabo
virtualización. Tiene la limitación de que la *máquina invitada* debe
tener el mismo kernel y misma CPU que la máquina anfitriona, pero si
esto no es un problema, puede resultar una alternativa útil y ligera a
la misma.

<div class='ejercicios' markdown="1">
Instala LXC en tu versión de Linux favorita.
</div>

No todos los núcleos pueden usar este tipo de container; para empezar,
dependerá de cómo esté compilado, pero también del soporte que tenga
el hardware. `lxc-checkconfig` permite comprobar si está preparado
para usar este tipo de tecnología. Parte de la configuración se
refiere a la instalación de `cgroups`, que hemos visto antes; el resto
a los espacios de nombres y a capacidades *misceláneas* relacionadas
con la red y el sistema de ficheros. 

![Usando lxc-chkconfig](../img/lxcchkconfig.png)
